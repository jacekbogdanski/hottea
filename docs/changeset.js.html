<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: changeset.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: changeset.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>var {
  pick,
  omit,
  getByPath,
  isEqual,
  extend,
  curry,
  mapObj,
  isUndefined,
  unique
} = require('./utils')

/**
 * Allows for creating and manipulating changesets. As an entry point to create changeset use cast function.
 * @namespace changeset
 */

module.exports = mapObj(
  {
    /**
     * Applies properties as changes for the data model according to the set of keys.
     * @function cast
     * @memberof changeset
     * @param {Object} data - entity model data
     * @param {Object} attrs - changes
     * @param {Array} params - changes to pick
     * @example cast({id: 1, title: 'title'}, {title: 'new title', body: 'body'}, ['title', 'body'])
     * @returns {Object} changeset
     */
    cast: cast,

    /**
     * Casts association with the changeset parameters.
     * @function cast
     * @memberof changeset
     * @param {Object} data - entity model data
     * @param {Object} attrs - changes
     * @param {Array} params - changes to pick
     * @example cast({id: 1, title: 'title'}, {title: 'new title', body: 'body'}, ['title', 'body'])
     * @returns {Object} changeset
     */
    castAssoc({ field, change }, attrs, changeset) {
      var assoc = change(changeset.data[field] || {}, attrs || {})

      if (!Object.keys(assoc.changes).length) return changeset

      var changes = {}
      changes[field] = assoc
      changes = extend(changeset.changes, changes)

      return extend(changeset, {
        changes,
        valid: changeset.valid &amp;&amp; assoc.valid
      })
    },
    /**
     * Merges two changesets with the same data model.
     * If data models are not equal, function will throw error.
     * Changes, errors and action are merged into the second changeset.
     * @function merge
     * @memberof changeset
     * @param from {Object} from - source changeset
     * @param from {Object} to - target changeset
     * @returns {Object} changeset
     */
    merge(from, to) {
      if (!isEqual(from.data, to.data))
        throw 'Different data when merging changesets'

      var keys = Object.keys(to.changes)

      return {
        data: to.data,
        changes: extend(from.changes, to.changes),
        errors: extend(omit(keys, from.errors), to.errors),
        valid: from.valid &amp;&amp; to.valid
      }
    },
    /**
     * Gets change from the changeset.
     * @function getChange
     * @memberof changeset
     * @param field {String} - name of the change field
     * @param changeset {Object} - changeset with expected change
     * @returns {Array} Success/Error Array tuple with the change value
     * @example
     * // when change exists
     * getChange('title', changeset) === [true, 'some title']
     * // when change does not exist
     * getChange('title', changeset) === [false, null]
     */
    getChange(field, changeset) {
      var change = getByPath(['changes', field], changeset)
      if (isUndefined(change)) return [false, null]
      return [true, change]
    },
    /**
     * Puts change into changeset for the given field
     * @function putChange
     * @memberof changeset
     * @param field {String} - name of the change field
     * @param change {Any} - value of the change
     * @param changeset {Object} - target changeset
     * @returns {Object} changeset with the given change
     */
    putChange(field, change, changeset) {
      var changes = {}
      changes[field] = change
      changes = extend(changeset.changes, changes)
      return extend(changeset, { changes })
    },
    /**
     * Gets field from the changeset.
     * @function getField
     * @memberof changeset
     * @param field {String} - name of the field
     * @param changeset {Object} - changeset with expected field
     * @returns {Array} Success/Error Array tuple with the field value
     * @example
     * // when field exists
     * getField('title', changeset) === [true, 'some title']
     * // when field does not exist
     * getField('title', changeset) === [false, null]
     */
    getField(field, changeset) {
      var value = getByPath(['data', field], changeset)
      if (isUndefined(value)) return [false, null]
      return [true, value]
    },
    /**
     * Gets errors from the changeset for the given field.
     * @function getErrors
     * @memberof changeset
     * @param field {String} - name of the field
     * @param changeset {Object} - changeset with expected errors
     * @returns {Array} field errors
     */
    getErrors(field, changeset) {
      var errors = changeset.errors[field] || []
      return [...errors]
    },
    /**
     * Puts error to the changeset for given field
     * @function putError
     * @memberof changeset
     * @param field {String} - name of the field
     * @param error {Any} - works with any data, but preferably object with message:String property
     * @param changeset {Object} - target changeset
     * @returns {Object} changeset with given errors
     */
    putError(field, error, changeset) {
      var errorArr = changeset.errors[field] || []
      errorArr = [...errorArr, error]

      var errors = {}
      errors[field] = errorArr
      errors = extend(changeset.errors, errors)

      return extend(changeset, { errors, valid: false })
    },
    /**
     * Deletes change from the changeset
     * @function deleteChange
     * @memberof changeset
     * @param field {String} - name of the field
     * @changeset {Object} - target changeset
     * @returns {Object} changeset without given change
     */
    deleteChange(field, changeset) {
      var changes = omit([field], changeset.changes)
      var errors = omit([field], changeset.errors)
      return extend(changeset, { changes, errors })
    },
    /**
     * Applies action to the changeset only if the changes are valid.
     * If the changes are valid all changes will be merged with the data model.
     * @function applyAction
     * @memberof changeset
     * @param changeset {Object} - target changeset
     * @param action {String} - action name
     * @returns {Array} Success/Error Array tuple
     * @example
     * // with valid changes
     * applyChanges(oldChangeset, 'INSERT') === [true, oldChangeset]
     * oldChangeset.action === null
     * // with invalid changes
     * applyChanges(oldChangeset, 'INSERT') === [false, newChangeset]
     * newChangeset.action === 'INSERT'
     */
    applyAction(changeset, action) {
      if (!changeset.valid) return [false, changeset]

      var data = applyChanges(changeset)

      return [true, extend(cast(data, {}, []), { action })]
    },
    /**
     * Traverses through changeset errors and associations. With the given transform function will apply it to the error messages.
     * @function traverseErrors
     * @memberof changeset
     * @param changeset {Object} - target changeset
     * @param fn {Function} - transform function
     * @returns {Object} object with changeset errors corresponding to the changeset graph
     * @example
     * traverseErrors(changeset, function transform(field, opts){
     *  return `${field}: ${opts.message}`
     * })
     */
    traverseErrors: traverseErrors,
    /**
     * Applies changes to the data model regardless if the changes are valid or not.
     * @function applyChanges
     * @memberof changeset
     * @param changeset {Object} - target changeset
     * @returns {Object} data
     */
    applyChanges: applyChanges
  },
  (key, fn) => curry(fn)
)

function cast(data, attrs, fields) {
  var diff = fields.filter(field => !isEqual(data[field], attrs[field]))
  var changes = pick(diff, attrs)

  return {
    data,
    changes,
    errors: {},
    valid: true,
    action: null
  }
}

function traverseErrors(changeset, fn = null) {
  var { errors, changes } = changeset
  var keys = Object.keys(changes)

  return keys.reduce((cur, key) => {
    var error = errors[key]
    var change = changes[key]

    if (isChangeset(change)) {
      cur[key] = traverseErrors(change, fn)
      return cur
    }

    if (isUndefined(error)) return cur

    if (fn) {
      cur[key] = error.map(opts => fn(key, opts))
      return cur
    }

    cur[key] = error.map(opts => opts.message)
    return cur
  }, {})
}

function isChangeset(obj) {
  return (
    obj &amp;&amp;
    obj.hasOwnProperty('data') &amp;&amp;
    obj.hasOwnProperty('changes') &amp;&amp;
    obj.hasOwnProperty('errors') &amp;&amp;
    obj.hasOwnProperty('valid')
  )
}

function applyChanges(changeset) {
  var { data, changes } = changeset
  var keys = unique([...Object.keys(data), ...Object.keys(changes)])

  return keys.reduce((cur, key) => {
    var change = changes[key]

    if (isChangeset(change)) {
      cur[key] = applyChanges(change)
      return cur
    }

    if (isUndefined(change)) {
      cur[key] = data[key]
      return cur
    }

    cur[key] = change
    return cur
  }, {})
}
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Namespaces</h3><ul><li><a href="changeset.html">changeset</a></li><li><a href="validators.html">validators</a></li></ul><h3>Global</h3><ul><li><a href="global.html#from">from</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.5.5</a> on Sun Dec 17 2017 15:43:03 GMT+0100 (CET)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
